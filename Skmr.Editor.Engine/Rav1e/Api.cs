// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace Skmr.Editor.Engine.Rav1e
{
    /// <summary>Sample position for subsampled chroma</summary>
    public enum RaChromaSamplePosition
    {
        /// <summary>
        /// <para>The source video transfer function must be signaled</para>
        /// <para>outside the AV1 bitstream.</para>
        /// </summary>
        RA_CHROMA_SAMPLE_POSITION_UNKNOWN = 0,
        /// <summary>
        /// <para>Horizontally co-located with (0, 0) luma sample, vertically positioned</para>
        /// <para>in the middle between two luma samples.</para>
        /// </summary>
        RA_CHROMA_SAMPLE_POSITION_VERTICAL = 1,
        /// <summary>Co-located with (0, 0) luma sample.</summary>
        RA_CHROMA_SAMPLE_POSITION_COLOCATED = 2
    }

    /// <summary>Chroma subsampling format</summary>
    public enum RaChromaSampling
    {
        /// <summary>Both vertically and horizontally subsampled.</summary>
        RA_CHROMA_SAMPLING_CS420 = 0,
        /// <summary>Horizontally subsampled.</summary>
        RA_CHROMA_SAMPLING_CS422 = 1,
        /// <summary>Not subsampled.</summary>
        RA_CHROMA_SAMPLING_CS444 = 2,
        /// <summary>Monochrome.</summary>
        RA_CHROMA_SAMPLING_CS400 = 3
    }

    /// <summary>Supported Color Primaries</summary>
    /// <remarks>As defined by “Color primaries” section of ISO/IEC 23091-4/ITU-T H.273</remarks>
    public enum RaColorPrimaries
    {
        /// <summary>BT.709</summary>
        RA_COLOR_PRIMARIES_BT709 = 1,
        /// <summary>Unspecified, must be signaled or inferred outside of the bitstream</summary>
        RA_COLOR_PRIMARIES_UNSPECIFIED = 2,
        /// <summary>BT.470 System M (historical)</summary>
        RA_COLOR_PRIMARIES_BT470M = 4,
        /// <summary>BT.470 System B, G (historical)</summary>
        RA_COLOR_PRIMARIES_BT470BG = 5,
        /// <summary>BT.601-7 525 (SMPTE 170 M)</summary>
        RA_COLOR_PRIMARIES_BT601 = 6,
        /// <summary>SMPTE 240M (historical)</summary>
        RA_COLOR_PRIMARIES_SMPTE240 = 7,
        /// <summary>Generic film</summary>
        RA_COLOR_PRIMARIES_GENERIC_FILM = 8,
        /// <summary>BT.2020, BT.2100</summary>
        RA_COLOR_PRIMARIES_BT2020 = 9,
        /// <summary>SMPTE 248 (CIE 1921 XYZ)</summary>
        RA_COLOR_PRIMARIES_XYZ = 10,
        /// <summary>SMPTE RP 431-2</summary>
        RA_COLOR_PRIMARIES_SMPTE431 = 11,
        /// <summary>SMPTE EG 432-1</summary>
        RA_COLOR_PRIMARIES_SMPTE432 = 12,
        /// <summary>EBU Tech. 3213-E</summary>
        RA_COLOR_PRIMARIES_EBU3213 = 22
    }

    /// <summary>Status that can be returned by encoder functions.</summary>
    public enum RaEncoderStatus
    {
        /// <summary>Normal operation.</summary>
        RA_ENCODER_STATUS_SUCCESS = 0,
        /// <summary>The encoder needs more data to produce an output packet.</summary>
        /// <remarks>
        /// <para>May be emitted by `rav1e_receive_packet` when frame reordering is</para>
        /// <para>enabled.</para>
        /// </remarks>
        RA_ENCODER_STATUS_NEED_MORE_DATA = 1,
        /// <summary>There are enough frames in the queue.</summary>
        /// <remarks>
        /// <para>May be emitted by `rav1e_send_frame` when trying to send a frame after</para>
        /// <para>the encoder has been flushed or the internal queue is full.</para>
        /// </remarks>
        RA_ENCODER_STATUS_ENOUGH_DATA = 2,
        /// <summary>The encoder has already produced the number of frames requested.</summary>
        /// <remarks>
        /// <para>May be emitted by `rav1e_receive_packet` after a flush request had been</para>
        /// <para>processed or the frame limit had been reached.</para>
        /// </remarks>
        RA_ENCODER_STATUS_LIMIT_REACHED = 3,
        /// <summary>A Frame had been encoded but not emitted yet.</summary>
        RA_ENCODER_STATUS_ENCODED = 4,
        /// <summary>Generic fatal error.</summary>
        RA_ENCODER_STATUS_FAILURE = -1,
        /// <summary>
        /// <para>A frame was encoded in the first pass of a 2-pass encode, but its stats</para>
        /// <para>data was not retrieved with `rav1e_twopass_out`, or not enough stats data</para>
        /// <para>was provided in the second pass of a 2-pass encode to encode the next</para>
        /// <para>frame.</para>
        /// </summary>
        RA_ENCODER_STATUS_NOT_READY = -2
    }

    /// <summary>Possible types of a frame.</summary>
    public enum RaFrameType
    {
        /// <summary>Key frame.</summary>
        RA_FRAME_TYPE_KEY = 0,
        /// <summary>Inter-frame.</summary>
        RA_FRAME_TYPE_INTER = 1,
        /// <summary>Intra-only frame.</summary>
        RA_FRAME_TYPE_INTRA_ONLY = 2,
        /// <summary>Switching frame.</summary>
        RA_FRAME_TYPE_SWITCH = 3
    }

    /// <summary>Override the frame type decision</summary>
    /// <remarks>Only certain frame types can be selected.</remarks>
    public enum RaFrameTypeOverride
    {
        /// <summary>Do not force any decision.</summary>
        RA_FRAME_TYPE_OVERRIDE_NO = 0,
        /// <summary>Force the frame to be a Keyframe.</summary>
        RA_FRAME_TYPE_OVERRIDE_KEY = 1
    }

    /// <summary>Matrix coefficients</summary>
    /// <remarks>As defined by the “Matrix coefficients” section of ISO/IEC 23091-4/ITU-TH.273.</remarks>
    public enum RaMatrixCoefficients
    {
        /// <summary>Identity matrix</summary>
        RA_MATRIX_COEFFICIENTS_IDENTITY = 0,
        /// <summary>BT.709</summary>
        RA_MATRIX_COEFFICIENTS_BT709 = 1,
        /// <summary>Unspecified, must be signaled or inferred outside of the bitstream.</summary>
        RA_MATRIX_COEFFICIENTS_UNSPECIFIED = 2,
        /// <summary>US FCC 73.628</summary>
        RA_MATRIX_COEFFICIENTS_FCC = 4,
        /// <summary>BT.470 System B, G (historical)</summary>
        RA_MATRIX_COEFFICIENTS_BT470BG = 5,
        /// <summary>BT.601-7 525 (SMPTE 170 M)</summary>
        RA_MATRIX_COEFFICIENTS_BT601 = 6,
        /// <summary>SMPTE 240 M</summary>
        RA_MATRIX_COEFFICIENTS_SMPTE240 = 7,
        /// <summary>YCgCo</summary>
        RA_MATRIX_COEFFICIENTS_Y_CG_CO = 8,
        /// <summary>BT.2020 non-constant luminance, BT.2100 YCbCr</summary>
        RA_MATRIX_COEFFICIENTS_BT2020NCL = 9,
        /// <summary>BT.2020 constant luminance</summary>
        RA_MATRIX_COEFFICIENTS_BT2020CL = 10,
        /// <summary>SMPTE ST 2085 YDzDx</summary>
        RA_MATRIX_COEFFICIENTS_SMPTE2085 = 11,
        /// <summary>Chromaticity-derived non-constant luminance</summary>
        RA_MATRIX_COEFFICIENTS_CHROMAT_NCL = 12,
        /// <summary>Chromaticity-derived constant luminance</summary>
        RA_MATRIX_COEFFICIENTS_CHROMAT_CL = 13,
        /// <summary>BT.2020 ICtCp</summary>
        RA_MATRIX_COEFFICIENTS_I_CT_CP = 14
    }

    /// <summary>Allowed pixel value range</summary>
    /// <remarks>C.f. `VideoFullRangeFlag` variable specified in ISO/IEC 23091-4/ITU-T H.273</remarks>
    public enum RaPixelRange
    {
        /// <summary>Studio swing representation</summary>
        RA_PIXEL_RANGE_LIMITED = 0,
        /// <summary>Full swing representation</summary>
        RA_PIXEL_RANGE_FULL = 1
    }

    /// <summary>Rate Control Data</summary>
    public enum RaRcDataKind
    {
        /// <summary>A Rate Control Summary Packet</summary>
        /// <remarks>
        /// <para>It is emitted once, after the encoder is flushed.</para>
        /// <para>It contains a summary of the rate control information for the</para>
        /// <para>encoding process that just terminated.</para>
        /// </remarks>
        RA_RC_DATA_KIND_SUMMARY = 0,
        /// <summary>A Rate Control Frame-specific Packet</summary>
        /// <remarks>
        /// <para>It is emitted every time a frame is processed.</para>
        /// <para>The information contained is required to encode its matching</para>
        /// <para>frame in a second pass encoding.</para>
        /// </remarks>
        RA_RC_DATA_KIND_FRAME = 1,
        /// <summary>There is no pass data available for now</summary>
        /// <remarks>
        /// <para>This is emitted if `rav1e_rc_receive_pass_data` is called more</para>
        /// <para>often than it should.</para>
        /// </remarks>
        RA_RC_DATA_KIND_EMPTY = 2
    }

    /// <summary>Supported Transfer Characteristics</summary>
    /// <remarks>As defined by “Transfer characteristics” section of ISO/IEC 23091-4/ITU-TH.273.</remarks>
    public enum RaTransferCharacteristics
    {
        /// <summary>BT.709</summary>
        RA_TRANSFER_CHARACTERISTICS_BT709 = 1,
        /// <summary>Unspecified, must be signaled or inferred outside of the bitstream</summary>
        RA_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2,
        /// <summary>BT.470 System M (historical)</summary>
        RA_TRANSFER_CHARACTERISTICS_BT470M = 4,
        /// <summary>BT.470 System B, G (historical)</summary>
        RA_TRANSFER_CHARACTERISTICS_BT470BG = 5,
        /// <summary>BT.601-7 525 (SMPTE 170 M)</summary>
        RA_TRANSFER_CHARACTERISTICS_BT601 = 6,
        /// <summary>SMPTE 240 M</summary>
        RA_TRANSFER_CHARACTERISTICS_SMPTE240 = 7,
        /// <summary>Linear</summary>
        RA_TRANSFER_CHARACTERISTICS_LINEAR = 8,
        /// <summary>Logarithmic (100:1 range)</summary>
        RA_TRANSFER_CHARACTERISTICS_LOG100 = 9,
        /// <summary>Logarithmic ((100 * √10):1 range)</summary>
        RA_TRANSFER_CHARACTERISTICS_LOG100SQRT10 = 10,
        /// <summary>IEC 61966-2-4</summary>
        RA_TRANSFER_CHARACTERISTICS_IEC61966 = 11,
        /// <summary>BT.1361 extended color gamut system (historical)</summary>
        RA_TRANSFER_CHARACTERISTICS_BT1361 = 12,
        /// <summary>sRGB or sYCC</summary>
        RA_TRANSFER_CHARACTERISTICS_SRGB = 13,
        /// <summary>BT.2020 10-bit systems</summary>
        RA_TRANSFER_CHARACTERISTICS_BT2020_10BIT = 14,
        /// <summary>BT.2020 12-bit systems</summary>
        RA_TRANSFER_CHARACTERISTICS_BT2020_12BIT = 15,
        /// <summary>SMPTE ST 2084, ITU BT.2100 PQ</summary>
        RA_TRANSFER_CHARACTERISTICS_SMPTE2084 = 16,
        /// <summary>SMPTE ST 428</summary>
        RA_TRANSFER_CHARACTERISTICS_SMPTE428 = 17,
        /// <summary>BT.2100 HLG (Hybrid Log Gamma), ARIB STD-B67</summary>
        RA_TRANSFER_CHARACTERISTICS_HLG = 18
    }

    /// <summary>Sample position for subsampled chroma</summary>
    /// <summary>Chroma subsampling format</summary>
    /// <summary>Supported Color Primaries</summary>
    /// <remarks>As defined by “Color primaries” section of ISO/IEC 23091-4/ITU-T H.273</remarks>
    /// <summary>Status that can be returned by encoder functions.</summary>
    /// <summary>Possible types of a frame.</summary>
    /// <summary>Override the frame type decision</summary>
    /// <remarks>Only certain frame types can be selected.</remarks>
    /// <summary>Matrix coefficients</summary>
    /// <remarks>As defined by the “Matrix coefficients” section of ISO/IEC 23091-4/ITU-TH.273.</remarks>
    /// <summary>Allowed pixel value range</summary>
    /// <remarks>C.f. `VideoFullRangeFlag` variable specified in ISO/IEC 23091-4/ITU-T H.273</remarks>
    /// <summary>Rate Control Data</summary>
    /// <summary>Supported Transfer Characteristics</summary>
    /// <remarks>As defined by “Transfer characteristics” section of ISO/IEC 23091-4/ITU-TH.273.</remarks>
    /// <summary>Simple Data</summary>
    /// <remarks>Use `rav1e_data_unref()` to free its memory.</remarks>
    /// <summary>A rational number.</summary>
    /// <summary>
    /// <para>Chromaticity coordinates as defined by CIE 1931, expressed as 0.16</para>
    /// <para>fixed-point values.</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RaFrameOpaqueCb(__IntPtr __0);

    /// <summary>Encoded Packet</summary>
    /// <remarks>
    /// <para>The encoded packets are retrieved using `rav1e_receive_packet()`.</para>
    /// <para>Use `rav1e_packet_unref()` to free its memory.</para>
    /// </remarks>
    public unsafe partial class RaConfig
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Skmr.Editor.Engine.Rav1e.RaConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Skmr.Editor.Engine.Rav1e.RaConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RaConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RaConfig(native.ToPointer(), skipVTables);
        }

        internal static RaConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RaConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RaConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RaConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RaConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RaConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class RaContext
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaContext> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaContext>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Skmr.Editor.Engine.Rav1e.RaContext managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Skmr.Editor.Engine.Rav1e.RaContext managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RaContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RaContext(native.ToPointer(), skipVTables);
        }

        internal static RaContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RaContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RaContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RaContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RaContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RaContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class RaFrame
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaFrame> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaFrame>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Skmr.Editor.Engine.Rav1e.RaFrame managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Skmr.Editor.Engine.Rav1e.RaFrame managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RaFrame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RaFrame(native.ToPointer(), skipVTables);
        }

        internal static RaFrame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RaFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RaFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RaFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RaFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RaFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Simple Data</summary>
    /// <remarks>Use `rav1e_data_unref()` to free its memory.</remarks>
    public unsafe partial class RaData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr data;
            internal ulong len;

            [SuppressUnmanagedCodeSecurity, DllImport("Rav1e", EntryPoint = "??0RaData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Skmr.Editor.Engine.Rav1e.RaData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Skmr.Editor.Engine.Rav1e.RaData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RaData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RaData(native.ToPointer(), skipVTables);
        }

        internal static RaData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RaData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RaData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RaData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RaData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RaData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RaData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public RaData(global::Skmr.Editor.Engine.Rav1e.RaData __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Skmr.Editor.Engine.Rav1e.RaData.__Internal*) __Instance) = *((global::Skmr.Editor.Engine.Rav1e.RaData.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to the data buffer</summary>
        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }
        }

        /// <summary>Data buffer size</summary>
        public ulong Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }
    }

    /// <summary>A rational number.</summary>
    public unsafe partial class RaRational : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ulong num;
            internal ulong den;

            [SuppressUnmanagedCodeSecurity, DllImport("Rav1e", EntryPoint = "??0RaRational@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaRational> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaRational>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Skmr.Editor.Engine.Rav1e.RaRational managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Skmr.Editor.Engine.Rav1e.RaRational managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RaRational __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RaRational(native.ToPointer(), skipVTables);
        }

        internal static RaRational __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RaRational)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RaRational __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RaRational(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RaRational(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RaRational(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RaRational()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public RaRational(global::Skmr.Editor.Engine.Rav1e.RaRational __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal*) __Instance) = *((global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Numerator.</summary>
        public ulong Num
        {
            get
            {
                return ((__Internal*)__Instance)->num;
            }

            set
            {
                ((__Internal*)__Instance)->num = value;
            }
        }

        /// <summary>Denominator.</summary>
        public ulong Den
        {
            get
            {
                return ((__Internal*)__Instance)->den;
            }

            set
            {
                ((__Internal*)__Instance)->den = value;
            }
        }
    }

    /// <summary>
    /// <para>Chromaticity coordinates as defined by CIE 1931, expressed as 0.16</para>
    /// <para>fixed-point values.</para>
    /// </summary>
    public unsafe partial class RaChromaticityPoint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort x;
            internal ushort y;

            [SuppressUnmanagedCodeSecurity, DllImport("Rav1e", EntryPoint = "??0RaChromaticityPoint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RaChromaticityPoint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RaChromaticityPoint(native.ToPointer(), skipVTables);
        }

        internal static RaChromaticityPoint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RaChromaticityPoint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RaChromaticityPoint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RaChromaticityPoint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RaChromaticityPoint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RaChromaticityPoint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RaChromaticityPoint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public RaChromaticityPoint(global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal*) __Instance) = *((global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The X coordinate.</summary>
        public ushort X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>The Y coordinate.</summary>
        public ushort Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    /// <summary>Encoded Packet</summary>
    /// <remarks>
    /// <para>The encoded packets are retrieved using `rav1e_receive_packet()`.</para>
    /// <para>Use `rav1e_packet_unref()` to free its memory.</para>
    /// </remarks>
    public unsafe partial class RaPacket : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr data;
            internal ulong len;
            internal ulong input_frameno;
            internal global::Skmr.Editor.Engine.Rav1e.RaFrameType frame_type;
            internal __IntPtr opaque;
            internal __IntPtr rec;
            internal __IntPtr source;

            [SuppressUnmanagedCodeSecurity, DllImport("Rav1e", EntryPoint = "??0RaPacket@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaPacket> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Skmr.Editor.Engine.Rav1e.RaPacket>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Skmr.Editor.Engine.Rav1e.RaPacket managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Skmr.Editor.Engine.Rav1e.RaPacket managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RaPacket __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RaPacket(native.ToPointer(), skipVTables);
        }

        internal static RaPacket __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RaPacket)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RaPacket __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RaPacket(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RaPacket(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RaPacket(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RaPacket()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaPacket.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public RaPacket(global::Skmr.Editor.Engine.Rav1e.RaPacket __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Skmr.Editor.Engine.Rav1e.RaPacket.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Skmr.Editor.Engine.Rav1e.RaPacket.__Internal*) __Instance) = *((global::Skmr.Editor.Engine.Rav1e.RaPacket.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Encoded data buffer</summary>
        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }
        }

        /// <summary>Encoded data buffer size</summary>
        public ulong Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Frame sequence number</summary>
        public ulong InputFrameno
        {
            get
            {
                return ((__Internal*)__Instance)->input_frameno;
            }

            set
            {
                ((__Internal*)__Instance)->input_frameno = value;
            }
        }

        /// <summary>Frame type</summary>
        public global::Skmr.Editor.Engine.Rav1e.RaFrameType FrameType
        {
            get
            {
                return ((__Internal*)__Instance)->frame_type;
            }

            set
            {
                ((__Internal*)__Instance)->frame_type = value;
            }
        }

        /// <summary>User provided opaque data</summary>
        public __IntPtr Opaque
        {
            get
            {
                return ((__Internal*)__Instance)->opaque;
            }

            set
            {
                ((__Internal*)__Instance)->opaque = (__IntPtr) value;
            }
        }

        /// <summary>
        /// <para>The reconstruction of the shown frame.</para>
        /// <para>This is freed automatically by `rav1e_packet_unref()`.</para>
        /// </summary>
        public global::Skmr.Editor.Engine.Rav1e.RaFrame Rec
        {
            get
            {
                var __result0 = global::Skmr.Editor.Engine.Rav1e.RaFrame.__GetOrCreateInstance(((__Internal*)__Instance)->rec, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->rec = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>
        /// <para>The Reference Frame</para>
        /// <para>This is freed automatically by `rav1e_packet_unref()`.</para>
        /// </summary>
        public global::Skmr.Editor.Engine.Rav1e.RaFrame Source
        {
            get
            {
                var __result0 = global::Skmr.Editor.Engine.Rav1e.RaFrame.__GetOrCreateInstance(((__Internal*)__Instance)->source, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->source = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class Api
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_version_short", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eVersionShort();

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_version_full", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eVersionFull();

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_data_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eDataUnref(__IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_default", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eConfigDefault();

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_rc_summary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eConfigSetRcSummary(__IntPtr cfg, byte** data, ulong* len);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_emit_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eConfigSetEmitData(__IntPtr cfg, int emit);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_sample_aspect_ratio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eConfigSetSampleAspectRatio(__IntPtr cfg, global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal sample_aspect_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_time_base", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eConfigSetTimeBase(__IntPtr cfg, global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal time_base);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_pixel_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eConfigSetPixelFormat(__IntPtr cfg, byte bit_depth, global::Skmr.Editor.Engine.Rav1e.RaChromaSampling subsampling, global::Skmr.Editor.Engine.Rav1e.RaChromaSamplePosition chroma_pos, global::Skmr.Editor.Engine.Rav1e.RaPixelRange pixel_range);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_color_description", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eConfigSetColorDescription(__IntPtr cfg, global::Skmr.Editor.Engine.Rav1e.RaMatrixCoefficients matrix, global::Skmr.Editor.Engine.Rav1e.RaColorPrimaries primaries, global::Skmr.Editor.Engine.Rav1e.RaTransferCharacteristics transfer);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_content_light", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eConfigSetContentLight(__IntPtr cfg, ushort max_content_light_level, ushort max_frame_average_light_level);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_set_mastering_display", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eConfigSetMasteringDisplay(__IntPtr cfg, global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal[] primaries, global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal white_point, uint max_luminance, uint min_luminance);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eConfigUnref(__IntPtr cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_parse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eConfigParse(__IntPtr cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_config_parse_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eConfigParseInt(__IntPtr cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_context_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eContextNew(__IntPtr cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_context_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eContextUnref(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_frame_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eFrameNew(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_frame_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eFrameUnref(__IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_frame_set_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eFrameSetType(__IntPtr frame, global::Skmr.Editor.Engine.Rav1e.RaFrameTypeOverride frame_type);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_frame_set_opaque", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eFrameSetOpaque(__IntPtr frame, __IntPtr opaque, __IntPtr cb);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_frame_add_t35_metadata", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eFrameAddT35Metadata(__IntPtr frame, byte country_code, byte country_code_extension_byte, byte* data, ulong data_len);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_twopass_out", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eTwopassOut(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_rc_summary_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong Rav1eRcSummarySize(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_rc_receive_pass_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Skmr.Editor.Engine.Rav1e.RaRcDataKind Rav1eRcReceivePassData(__IntPtr ctx, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_rc_second_pass_data_required", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eRcSecondPassDataRequired(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_rc_send_pass_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eRcSendPassData(__IntPtr ctx, byte** data, ulong* len);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_twopass_bytes_needed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong Rav1eTwopassBytesNeeded(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_twopass_in", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Rav1eTwopassIn(__IntPtr ctx, byte* buf, ulong buf_size);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_send_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus Rav1eSendFrame(__IntPtr ctx, __IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_last_status", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus Rav1eLastStatus(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_status_to_str", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eStatusToStr(global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus status);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_receive_packet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus Rav1eReceivePacket(__IntPtr ctx, __IntPtr pkt);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_packet_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1ePacketUnref(__IntPtr pkt);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_container_sequence_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Rav1eContainerSequenceHeader(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_frame_fill_plane", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eFrameFillPlane(__IntPtr frame, int plane, byte* data, ulong data_len, long stride, int bytewidth);

            [SuppressUnmanagedCodeSecurity, DllImport("rav1e", EntryPoint = "rav1e_frame_extract_plane", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Rav1eFrameExtractPlane(__IntPtr frame, int plane, byte* data, ulong data_len, long stride, int bytewidth);
        }

        /// <summary>Version information as presented in `[package]` `version`.</summary>
        /// <remarks>
        /// <para>e.g. `0.1.0`</para>
        /// <para>Can be parsed by [semver](https://crates.io/crates/semver).</para>
        /// <para>This returns the version of the loaded library, regardless</para>
        /// <para>of which version the library user was built against.</para>
        /// </remarks>
        public static string Rav1eVersionShort()
        {
            var ___ret = __Internal.Rav1eVersionShort();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>
        /// <para>Version information with the information</para>
        /// <para>provided by `git describe --tags`.</para>
        /// </summary>
        /// <remarks>
        /// <para>e.g. `0.1.0 (v0.1.0-1-g743d464)`</para>
        /// <para>This returns the version of the loaded library, regardless</para>
        /// <para>of which version the library user was built against.</para>
        /// </remarks>
        public static string Rav1eVersionFull()
        {
            var ___ret = __Internal.Rav1eVersionFull();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Free a `RaData` buffer</summary>
        public static void Rav1eDataUnref(global::Skmr.Editor.Engine.Rav1e.RaData data)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            __Internal.Rav1eDataUnref(__arg0);
        }

        /// <summary>Create a `RaConfig` filled with default parameters.</summary>
        public static global::Skmr.Editor.Engine.Rav1e.RaConfig Rav1eConfigDefault()
        {
            var ___ret = __Internal.Rav1eConfigDefault();
            var __result0 = global::Skmr.Editor.Engine.Rav1e.RaConfig.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Setup a second pass rate control using the provided summary</summary>
        /// <remarks>
        /// <para>Passing `NULL` data resets the rate control settings.</para>
        /// <para>If additional data is required, pointer and len stay unchanged, otherwise</para>
        /// <para>they are updated.</para>
        /// <para>Return:</para>
        /// <para>`0` on success</para>
        /// <para>`&gt; 0` if the buffer has to be larger</para>
        /// <para>`&lt;&gt;0` on failure</para>
        /// </remarks>
        public static int Rav1eConfigSetRcSummary(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, byte** data, ref ulong len)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            fixed (ulong* __len2 = &len)
            {
                var __arg2 = __len2;
                var ___ret = __Internal.Rav1eConfigSetRcSummary(__arg0, data, __arg2);
                return ___ret;
            }
        }

        /// <summary>Request to emit pass data</summary>
        /// <remarks>Set emit to 0 to not emit pass data, non-zero to emit pass data.</remarks>
        public static void Rav1eConfigSetEmitData(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, int emit)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            __Internal.Rav1eConfigSetEmitData(__arg0, emit);
        }

        /// <summary>Set the display aspect ratio of the stream</summary>
        /// <remarks>Needed for anamorphic video.</remarks>
        public static void Rav1eConfigSetSampleAspectRatio(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, global::Skmr.Editor.Engine.Rav1e.RaRational sample_aspect_ratio)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            if (ReferenceEquals(sample_aspect_ratio, null))
                throw new global::System.ArgumentNullException("sample_aspect_ratio", "Cannot be null because it is passed by value.");
            var __arg1 = sample_aspect_ratio.__Instance;
            __Internal.Rav1eConfigSetSampleAspectRatio(__arg0, *(global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal*) __arg1);
        }

        /// <summary>Set the time base of the stream</summary>
        /// <remarks>Needed for rate control.</remarks>
        public static void Rav1eConfigSetTimeBase(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, global::Skmr.Editor.Engine.Rav1e.RaRational time_base)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            if (ReferenceEquals(time_base, null))
                throw new global::System.ArgumentNullException("time_base", "Cannot be null because it is passed by value.");
            var __arg1 = time_base.__Instance;
            __Internal.Rav1eConfigSetTimeBase(__arg0, *(global::Skmr.Editor.Engine.Rav1e.RaRational.__Internal*) __arg1);
        }

        /// <summary>Set pixel format of the stream.</summary>
        /// <remarks>
        /// <para>Supported values for `subsampling` and `chroma_pos` are defined by the</para>
        /// <para>enum types `RaChromaSampling` and `RaChromaSamplePosition` respectively.</para>
        /// <para>Valid values for `pixel_range` are 0 and 1.</para>
        /// <para>Returns a negative value on error or 0.</para>
        /// </remarks>
        public static int Rav1eConfigSetPixelFormat(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, byte bit_depth, global::Skmr.Editor.Engine.Rav1e.RaChromaSampling subsampling, global::Skmr.Editor.Engine.Rav1e.RaChromaSamplePosition chroma_pos, global::Skmr.Editor.Engine.Rav1e.RaPixelRange pixel_range)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.Rav1eConfigSetPixelFormat(__arg0, bit_depth, subsampling, chroma_pos, pixel_range);
            return ___ret;
        }

        /// <summary>Set color properties of the stream.</summary>
        /// <remarks>
        /// <para>Supported values are defined by the enum types</para>
        /// <para>`RaMatrixCoefficients`, `RaColorPrimaries`, and `RaTransferCharacteristics`</para>
        /// <para>respectively.</para>
        /// <para>Return a negative value on error or 0.</para>
        /// </remarks>
        public static int Rav1eConfigSetColorDescription(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, global::Skmr.Editor.Engine.Rav1e.RaMatrixCoefficients matrix, global::Skmr.Editor.Engine.Rav1e.RaColorPrimaries primaries, global::Skmr.Editor.Engine.Rav1e.RaTransferCharacteristics transfer)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.Rav1eConfigSetColorDescription(__arg0, matrix, primaries, transfer);
            return ___ret;
        }

        /// <summary>Set the content light level information for HDR10 streams.</summary>
        /// <remarks>Return a negative value on error or 0.</remarks>
        public static int Rav1eConfigSetContentLight(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, ushort max_content_light_level, ushort max_frame_average_light_level)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.Rav1eConfigSetContentLight(__arg0, max_content_light_level, max_frame_average_light_level);
            return ___ret;
        }

        /// <summary>Set the mastering display information for HDR10 streams.</summary>
        /// <remarks>
        /// <para>`primaries` and `white_point` arguments are `RaChromaticityPoint`,</para>
        /// <para>containing 0.16 fixed point values.</para>
        /// <para>`max_luminance` is a 24.8 fixed point value.</para>
        /// <para>`min_luminance` is a 18.14 fixed point value.</para>
        /// <para>Returns a negative value on error or 0.</para>
        /// </remarks>
        public static int Rav1eConfigSetMasteringDisplay(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint[] primaries, global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint white_point, uint max_luminance, uint min_luminance)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            if (primaries == null || primaries.Length != 3)
                throw new ArgumentOutOfRangeException("primaries", "The dimensions of the provided array don't match the required size.");
            global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal[] __primaries;
            if (primaries == null)
                __primaries = null;
            else
            {
                __primaries = new global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal[primaries.Length];
                for (int i = 0; i < __primaries.Length; i++)
                {
                    var __element = primaries[i];
                    __primaries[i] = __element is null ? new global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal() : *(global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal*) __element.__Instance;
                }
            }
            var __arg1 = __primaries;
            if (ReferenceEquals(white_point, null))
                throw new global::System.ArgumentNullException("white_point", "Cannot be null because it is passed by value.");
            var __arg2 = white_point.__Instance;
            var ___ret = __Internal.Rav1eConfigSetMasteringDisplay(__arg0, __arg1, *(global::Skmr.Editor.Engine.Rav1e.RaChromaticityPoint.__Internal*) __arg2, max_luminance, min_luminance);
            return ___ret;
        }

        /// <summary>Free the `RaConfig`.</summary>
        public static void Rav1eConfigUnref(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            __Internal.Rav1eConfigUnref(__arg0);
        }

        /// <summary>Set a configuration parameter using its key and value as string.</summary>
        /// <remarks>
        /// <para>Available keys and values</para>
        /// <para>- `&quot;width&quot;`: width of the frame, default `640`</para>
        /// <para>- `&quot;height&quot;`: height of the frame, default `480`</para>
        /// <para>- `&quot;speed&quot;`: 0-10, default `6`</para>
        /// <para>- `&quot;threads&quot;`: maximum number of threads to be used, default auto</para>
        /// <para>- `&quot;tune&quot;`: `&quot;psnr&quot;` or `&quot;psychovisual&quot;`, default `&quot;psychovisual&quot;`</para>
        /// <para>- `&quot;quantizer&quot;`: 0-255, default `100`</para>
        /// <para>- `&quot;tiles&quot;`: total number of tiles desired (0 denotes auto), default `0`</para>
        /// <para>- `&quot;tile_rows&quot;`: number of tiles horizontally (must be a power of two, overridden by tiles if present), default `0`</para>
        /// <para>- `&quot;tile_cols&quot;`: number of tiles vertically (must be a power of two, overridden by tiles if present), default `0`</para>
        /// <para>- `&quot;min_quantizer&quot;`: minimum allowed base quantizer to use in bitrate mode, default `0`</para>
        /// <para>- `&quot;bitrate&quot;`: target bitrate for the bitrate mode (required for two pass mode), default `0`</para>
        /// <para>- `&quot;key_frame_interval&quot;`: maximum interval between two keyframes, default `240`</para>
        /// <para>- `&quot;min_key_frame_interval&quot;`: minimum interval between two keyframes, default `12`</para>
        /// <para>- `&quot;switch_frame_interval&quot;`: interval between switch frames, default `0`</para>
        /// <para>- `&quot;reservoir_frame_delay&quot;`: number of temporal units over which to distribute the reservoir usage, default `None`</para>
        /// <para>- `&quot;rdo_lookahead_frames&quot;`: number of frames to read ahead for the RDO lookahead computation, default `40`</para>
        /// <para>- `&quot;low_latency&quot;`: flag to enable low latency mode, default `false`</para>
        /// <para>- `&quot;enable_timing_info&quot;`: flag to enable signaling timing info in the bitstream, default `false`</para>
        /// <para>- `&quot;still_picture&quot;`: flag for still picture mode, default `false`</para>
        /// <para>Return a negative value on error or 0.</para>
        /// </remarks>
        public static int Rav1eConfigParse(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, string key, string value)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.Rav1eConfigParse(__arg0, key, value);
            return ___ret;
        }

        /// <summary>Set a configuration parameter using its key and value as integer.</summary>
        /// <remarks>
        /// <para>Available keys and values are the same as `rav1e_config_parse()`</para>
        /// <para>Return a negative value on error or 0.</para>
        /// </remarks>
        public static int Rav1eConfigParseInt(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg, string key, int value)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.Rav1eConfigParseInt(__arg0, key, value);
            return ___ret;
        }

        /// <summary>Generate a new encoding context from a populated encoder configuration</summary>
        /// <remarks>
        /// <para>Multiple contexts can be generated through it.</para>
        /// <para>Returns `Null` if context creation failed, e.g. by passing</para>
        /// <para>an invalid `Config`.</para>
        /// </remarks>
        public static global::Skmr.Editor.Engine.Rav1e.RaContext Rav1eContextNew(global::Skmr.Editor.Engine.Rav1e.RaConfig cfg)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.Rav1eContextNew(__arg0);
            var __result0 = global::Skmr.Editor.Engine.Rav1e.RaContext.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free the `RaContext`.</summary>
        public static void Rav1eContextUnref(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.Rav1eContextUnref(__arg0);
        }

        /// <summary>Produce a new frame from the encoding context</summary>
        /// <remarks>
        /// <para>It must be populated using `rav1e_frame_fill_plane()`.</para>
        /// <para>The frame is reference counted and must be released passing it to `rav1e_frame_unref()`,</para>
        /// <para>see `rav1e_send_frame()`.</para>
        /// </remarks>
        public static global::Skmr.Editor.Engine.Rav1e.RaFrame Rav1eFrameNew(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eFrameNew(__arg0);
            var __result0 = global::Skmr.Editor.Engine.Rav1e.RaFrame.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free the `RaFrame`.</summary>
        public static void Rav1eFrameUnref(global::Skmr.Editor.Engine.Rav1e.RaFrame frame)
        {
            var __arg0 = frame is null ? __IntPtr.Zero : frame.__Instance;
            __Internal.Rav1eFrameUnref(__arg0);
        }

        /// <summary>Overrides the encoders frame type decision for a frame</summary>
        /// <remarks>Must be called before `rav1e_send_frame()` if used.</remarks>
        public static int Rav1eFrameSetType(global::Skmr.Editor.Engine.Rav1e.RaFrame frame, global::Skmr.Editor.Engine.Rav1e.RaFrameTypeOverride frame_type)
        {
            var __arg0 = frame is null ? __IntPtr.Zero : frame.__Instance;
            var ___ret = __Internal.Rav1eFrameSetType(__arg0, frame_type);
            return ___ret;
        }

        /// <summary>Register an opaque data and a destructor to the frame</summary>
        /// <remarks>
        /// <para>It takes the ownership of its memory:</para>
        /// <para>- it will relinquish the ownership to the context if</para>
        /// <para>`rav1e_send_frame` is called.</para>
        /// <para>- it will call the destructor if `rav1e_frame_unref` is called</para>
        /// <para>otherwise.</para>
        /// </remarks>
        public static void Rav1eFrameSetOpaque(global::Skmr.Editor.Engine.Rav1e.RaFrame frame, __IntPtr opaque, global::Skmr.Editor.Engine.Rav1e.RaFrameOpaqueCb cb)
        {
            var __arg0 = frame is null ? __IntPtr.Zero : frame.__Instance;
            var __arg2 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.Rav1eFrameSetOpaque(__arg0, opaque, __arg2);
        }

        /// <summary>Add generic T35 metadata to a frame</summary>
        /// <remarks>
        /// <para>The buffer will be copied into the frame and can be freed</para>
        /// <para>immediately after this call.</para>
        /// <para>Can be called multiple times to add multiple T35 metadata</para>
        /// <para>blocks.</para>
        /// </remarks>
        public static void Rav1eFrameAddT35Metadata(global::Skmr.Editor.Engine.Rav1e.RaFrame frame, byte country_code, byte country_code_extension_byte, byte* data, ulong data_len)
        {
            var __arg0 = frame is null ? __IntPtr.Zero : frame.__Instance;
            __Internal.Rav1eFrameAddT35Metadata(__arg0, country_code, country_code_extension_byte, data, data_len);
        }

        /// <summary>
        /// <para>Retrieve the first-pass data of a two-pass encode for the frame that was</para>
        /// <para>just encoded. This should be called BEFORE every call to `rav1e_receive_packet()`</para>
        /// <para>(including the very first one), even if no packet was produced by the</para>
        /// <para>last call to `rav1e_receive_packet`, if any (i.e., `RA_ENCODER_STATUS_ENCODED`</para>
        /// <para>was returned). It needs to be called once more after</para>
        /// <para>`RA_ENCODER_STATUS_LIMIT_REACHED` is returned, to retrieve the header that</para>
        /// <para>should be written to the front of the stats file (overwriting the</para>
        /// <para>placeholder header that was emitted at the start of encoding).</para>
        /// </summary>
        /// <remarks>
        /// <para>It is still safe to call this function when `rav1e_receive_packet()` returns any</para>
        /// <para>other error. It will return `NULL` instead of returning a duplicate copy</para>
        /// <para>of the previous frame's data.</para>
        /// <para>Must be freed with `rav1e_data_unref()`.</para>
        /// </remarks>
        public static global::Skmr.Editor.Engine.Rav1e.RaData Rav1eTwopassOut(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eTwopassOut(__arg0);
            var __result0 = global::Skmr.Editor.Engine.Rav1e.RaData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Return the Rate Control Summary Packet size</summary>
        /// <remarks>
        /// <para>It is useful mainly to preserve space when saving</para>
        /// <para>both Rate Control Summary and Frame Packets in a single file</para>
        /// </remarks>
        public static ulong Rav1eRcSummarySize(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eRcSummarySize(__arg0);
            return ___ret;
        }

        /// <summary>Return the first pass data</summary>
        /// <remarks>
        /// <para>Call it after `rav1e_receive_packet()` returns a normal condition status:</para>
        /// <para>- `EncoderStatus::Encoded`,</para>
        /// <para>- `EncoderStatus::Success`,</para>
        /// <para>- `EncoderStatus::LimitReached`.</para>
        /// <para>use `rav1e_data_unref()` to free the data.</para>
        /// <para>It will return a `RcDataKind::Summary` once the encoder is flushed.</para>
        /// </remarks>
        public static global::Skmr.Editor.Engine.Rav1e.RaRcDataKind Rav1eRcReceivePassData(global::Skmr.Editor.Engine.Rav1e.RaContext ctx, global::Skmr.Editor.Engine.Rav1e.RaData data)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ____arg1 = data is null ? __IntPtr.Zero : data.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.Rav1eRcReceivePassData(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Number of pass data packets required to progress the encoding process.</summary>
        /// <remarks>
        /// <para>At least that number of packets must be passed before the encoder can</para>
        /// <para>progress.</para>
        /// <para>Stop feeding-in pass data packets once the function returns 0.</para>
        /// <para>``` c</para>
        /// <para>while (rav1e_rc_second_pass_data_required(ctx) &gt; 0) {</para>
        /// <para>int more = rav1e_rc_send_pass_data(ctx,&amp;data,&amp;len);</para>
        /// <para>if (more &gt; 0) {</para>
        /// <para>refill(&amp;data,&amp;len);</para>
        /// <para>} else if (more&lt;&gt;0) {</para>
        /// <para>goto fail;</para>
        /// <para>}</para>
        /// <para>}</para>
        /// <para>```</para>
        /// </remarks>
        public static int Rav1eRcSecondPassDataRequired(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eRcSecondPassDataRequired(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Feed the first pass Rate Control data to the encoder,</para>
        /// <para>Frame-specific Packets only.</para>
        /// </summary>
        /// <remarks>
        /// <para>Call it before `receive_packet()`</para>
        /// <para>If additional data is required, pointer and len stay unchanged, otherwise</para>
        /// <para>they are updated.</para>
        /// <para>Returns:</para>
        /// <para>- `0` on success,</para>
        /// <para>- `&gt; 0` the amount of bytes needed</para>
        /// <para>- `&lt;&gt;0` on unrecoverable failure</para>
        /// </remarks>
        public static int Rav1eRcSendPassData(global::Skmr.Editor.Engine.Rav1e.RaContext ctx, byte** data, ref ulong len)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            fixed (ulong* __len2 = &len)
            {
                var __arg2 = __len2;
                var ___ret = __Internal.Rav1eRcSendPassData(__arg0, data, __arg2);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Ask how many bytes of the stats file are needed before the next frame</para>
        /// <para>of the second pass in a two-pass encode can be encoded. This is a lower</para>
        /// <para>bound (more might be required), but if 0 is returned, then encoding can</para>
        /// <para>proceed. This is just a hint to the application, and does not need to</para>
        /// <para>be called for encoding the second pass to work, so long as the</para>
        /// <para>application continues to provide more data to `rav1e_twopass_in()` in a loop</para>
        /// <para>until `rav1e_twopass_in()` returns 0.</para>
        /// </summary>
        public static ulong Rav1eTwopassBytesNeeded(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eTwopassBytesNeeded(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Provide stats data produced in the first pass of a two-pass encode to the</para>
        /// <para>second pass. On success this returns the number of bytes of that data</para>
        /// <para>which were consumed. When encoding the second pass of a two-pass encode,</para>
        /// <para>this should be called repeatedly in a loop before every call to</para>
        /// <para>`rav1e_receive_packet()` (including the very first one) until no bytes are</para>
        /// <para>consumed, or until `twopass_bytes_needed()` returns 0. Returns -1 on failure.</para>
        /// </summary>
        public static int Rav1eTwopassIn(global::Skmr.Editor.Engine.Rav1e.RaContext ctx, byte* buf, ulong buf_size)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eTwopassIn(__arg0, buf, buf_size);
            return ___ret;
        }

        /// <summary>Send the frame for encoding</summary>
        /// <remarks>
        /// <para>The function increases the frame internal reference count and it can be passed multiple</para>
        /// <para>times to different `rav1e_send_frame()` with a caveat:</para>
        /// <para>The opaque data, if present, will be moved from the `Frame` to the `Context`</para>
        /// <para>and returned by `rav1e_receive_packet` in the `Packet` `opaque` field or</para>
        /// <para>the destructor will be called on `rav1e_context_unref` if the frame is</para>
        /// <para>still pending in the encoder.</para>
        /// <para>Returns:</para>
        /// <para>- `0` on success,</para>
        /// <para>- `&gt; 0` if the input queue is full</para>
        /// <para>- `&lt;&gt;0` on unrecoverable failure</para>
        /// </remarks>
        public static global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus Rav1eSendFrame(global::Skmr.Editor.Engine.Rav1e.RaContext ctx, global::Skmr.Editor.Engine.Rav1e.RaFrame frame)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = frame is null ? __IntPtr.Zero : frame.__Instance;
            var ___ret = __Internal.Rav1eSendFrame(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Return the last encoder status</summary>
        public static global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus Rav1eLastStatus(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eLastStatus(__arg0);
            return ___ret;
        }

        /// <summary>Return a static string matching the `EncoderStatus` variant.</summary>
        public static string Rav1eStatusToStr(global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus status)
        {
            var ___ret = __Internal.Rav1eStatusToStr(status);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Receive encoded data</summary>
        /// <remarks>
        /// <para>Returns:</para>
        /// <para>- `0` on success</para>
        /// <para>- `&gt; 0` if additional frame data is required</para>
        /// <para>- `&lt;&gt;0` on unrecoverable failure</para>
        /// </remarks>
        public static global::Skmr.Editor.Engine.Rav1e.RaEncoderStatus Rav1eReceivePacket(global::Skmr.Editor.Engine.Rav1e.RaContext ctx, global::Skmr.Editor.Engine.Rav1e.RaPacket pkt)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ____arg1 = pkt is null ? __IntPtr.Zero : pkt.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.Rav1eReceivePacket(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Free the `RaPacket`.</summary>
        public static void Rav1ePacketUnref(global::Skmr.Editor.Engine.Rav1e.RaPacket pkt)
        {
            var __arg0 = pkt is null ? __IntPtr.Zero : pkt.__Instance;
            __Internal.Rav1ePacketUnref(__arg0);
        }

        /// <summary>Produce a sequence header matching the current encoding context</summary>
        /// <remarks>
        /// <para>Its format is compatible with the AV1 Matroska and ISOBMFF specification.</para>
        /// <para>Use `rav1e_data_unref()` to free it.</para>
        /// </remarks>
        public static global::Skmr.Editor.Engine.Rav1e.RaData Rav1eContainerSequenceHeader(global::Skmr.Editor.Engine.Rav1e.RaContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.Rav1eContainerSequenceHeader(__arg0);
            var __result0 = global::Skmr.Editor.Engine.Rav1e.RaData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Fill a frame plane</summary>
        /// <remarks>
        /// <para>Currently the frame contains 3 planes, the first is luminance followed by</para>
        /// <para>chrominance.</para>
        /// <para>The data is copied and this function has to be called for each plane.</para>
        /// <para>`frame`: A frame provided by `rav1e_frame_new()`</para>
        /// <para>`plane`: The index of the plane starting from 0</para>
        /// <para>`data`: The data to be copied</para>
        /// <para>`data_len`: Length of the buffer</para>
        /// <para>`stride`: Plane line in bytes, including padding</para>
        /// <para>`bytewidth`: Number of bytes per component, either 1 or 2</para>
        /// </remarks>
        public static void Rav1eFrameFillPlane(global::Skmr.Editor.Engine.Rav1e.RaFrame frame, int plane, byte* data, ulong data_len, long stride, int bytewidth)
        {
            var __arg0 = frame is null ? __IntPtr.Zero : frame.__Instance;
            __Internal.Rav1eFrameFillPlane(__arg0, plane, data, data_len, stride, bytewidth);
        }

        /// <summary>Extract a frame plane</summary>
        /// <remarks>
        /// <para>This is the reverse of `rav1e_frame_fill_plane()`, primarily used for</para>
        /// <para>extracting the source and reconstruction data from a `RaPacket`.</para>
        /// <para>Currently the frame contains 3 planes, the first is luminance followed by</para>
        /// <para>chrominance.</para>
        /// <para>The data is copied out of the frame for a single plane.</para>
        /// <para>`frame`: A frame provided inside a packet returned by `rav1e_receive_packet()`</para>
        /// <para>`plane`: The index of the plane starting from 0</para>
        /// <para>`data`: The destination for the data</para>
        /// <para>`data_len`: Length of the buffer</para>
        /// <para>`stride`: Plane line in bytes, including padding</para>
        /// <para>`bytewidth`: Number of bytes per component, either 1 or 2</para>
        /// </remarks>
        public static void Rav1eFrameExtractPlane(global::Skmr.Editor.Engine.Rav1e.RaFrame frame, int plane, byte* data, ulong data_len, long stride, int bytewidth)
        {
            var __arg0 = frame is null ? __IntPtr.Zero : frame.__Instance;
            __Internal.Rav1eFrameExtractPlane(__arg0, plane, data, data_len, stride, bytewidth);
        }
    }
}
